<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Ikat Pattern v18 - Edge Wobble</title>
  <style>
    body { margin: 0; background: #f5f0e6; overflow: hidden; }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #1a237e;
      font-family: system-ui;
      font-size: 14px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Ikat v18: Edge Wobble</h2>
    <p>Hand-drawn resist lines</p>
    <p>Move mouse to draw</p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script>
    const IKAT_COLORS = [
      [0, 131, 143],    // turquoise
      [183, 28, 28],    // crimson
      [255, 193, 7],    // gold
      [106, 27, 154],   // purple
      [26, 35, 126],    // indigo
      [233, 30, 99],    // magenta
      [46, 125, 50],    // green
      [27, 94, 32],     // dark green
      [0, 150, 136],    // teal green
      [33, 150, 243],   // blue
      [13, 71, 161],    // dark blue
      [3, 169, 244],    // light blue
      [20, 20, 20],     // black
      [250, 250, 250],  // white
    ];

    const BG_COLOR = [245, 240, 230];

    let medallions = [];
    let prevMouse = { x: 0, y: 0 };

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(RGB);
      noStroke();
    }

    function draw() {
      background(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], 12);

      if (mouseX > 0 && mouseY > 0) {
        const dist = Math.sqrt(
          Math.pow(mouseX - prevMouse.x, 2) +
          Math.pow(mouseY - prevMouse.y, 2)
        );

        if (dist > 12) {
          spawnMedallion(mouseX, mouseY);
          prevMouse = { x: mouseX, y: mouseY };
        }
      }

      updateMedallions();
      drawMedallions();
    }

    function pickUniqueColors(count) {
      const colors = [];
      const available = [...IKAT_COLORS];

      for (let i = 0; i < count && available.length > 0; i++) {
        const idx = floor(random(available.length));
        colors.push(available.splice(idx, 1)[0]);
      }

      return colors;
    }

    function spawnMedallion(x, y) {
      const numLayers = floor(random(2, 6));
      const colors = pickUniqueColors(numLayers);

      const ratio = random(2, 3.5);
      const baseWidth = random(70, 130);
      const baseHeight = baseWidth * ratio;

      // Unique seed for wobble pattern per medallion
      const wobbleSeed = random(1000);

      const layers = [];
      for (let i = 0; i < numLayers; i++) {
        const scale = i === 0 ? 1 : random(0.5, 0.7);
        const prevLayer = i === 0 ? { width: baseWidth, height: baseHeight } : layers[i - 1];

        const offsetX = random(-2, 2);
        const offsetY = random(-2, 2);

        // Random blur (40% chance)
        const hasBlur = random() < 0.4;
        const blurAmount = hasBlur ? random(4, 10) : 0;

        // Wobble intensity varies per layer
        const wobbleAmount = random(2, 6);

        layers.push({
          width: prevLayer.width * scale,
          height: prevLayer.height * scale,
          color: colors[i],
          offsetX: offsetX,
          offsetY: offsetY,
          blur: blurAmount,
          hasBlur: hasBlur,
          wobble: wobbleAmount,
          wobbleOffset: random(100) // unique phase per layer
        });
      }

      const hasCenter = random() < 0.08;

      medallions.push({
        x: x,
        y: y,
        layers: layers,
        hasCenter: hasCenter,
        centerColor: hasCenter ? (random() < 0.5 ? BG_COLOR : [255, 215, 0]) : null,
        centerBlur: hasCenter && random() < 0.3,
        wobbleSeed: wobbleSeed,
        life: 1,
        decay: random(0.002, 0.005)
      });

      if (medallions.length > 50) medallions.shift();
    }

    function updateMedallions() {
      for (let i = medallions.length - 1; i >= 0; i--) {
        const m = medallions[i];
        m.life -= m.decay;

        if (m.life <= 0) {
          medallions.splice(i, 1);
        }
      }
    }

    function drawMedallions() {
      for (const m of medallions) {
        drawIkatMedallion(m);
      }
    }

    function drawIkatMedallion(m) {
      const alpha = m.life * 255;

      push();
      translate(m.x, m.y);

      // Draw layers from outside in
      for (let li = 0; li < m.layers.length; li++) {
        const layer = m.layers[li];
        push();
        translate(layer.offsetX, layer.offsetY);

        if (layer.hasBlur) {
          drawBlurredWobblyMedallion(0, 0, layer.width, layer.height, layer.color, alpha, layer.blur, layer.wobble, m.wobbleSeed + layer.wobbleOffset);
        } else {
          drawWobblyMedallion(0, 0, layer.width, layer.height, layer.color, alpha, layer.wobble, m.wobbleSeed + layer.wobbleOffset);
        }
        pop();
      }

      // Center diamond
      if (m.hasCenter && m.layers.length > 0) {
        const innermost = m.layers[m.layers.length - 1];
        const cw = innermost.width * 0.4;
        const ch = innermost.height * 0.25;

        if (m.centerBlur) {
          for (let b = 3; b >= 0; b--) {
            const expand = b * 2;
            const a = alpha * (0.15 - b * 0.03);
            fill(m.centerColor[0], m.centerColor[1], m.centerColor[2], a);
            drawWobblyDiamond(0, 0, cw + expand, ch + expand, 1.5, m.wobbleSeed + 50);
          }
        }

        fill(m.centerColor[0], m.centerColor[1], m.centerColor[2], alpha * 0.9);
        drawWobblyDiamond(0, 0, cw, ch, 1.5, m.wobbleSeed + 50);
      }

      pop();
    }

    function drawWobblyDiamond(cx, cy, w, h, wobbleAmt, seed) {
      const steps = 12;
      beginShape();

      // Top to right
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = cx + t * (w / 2);
        const y = cy - (h / 2) * (1 - t);
        const wobble = noise(seed + i * 0.3) * wobbleAmt - wobbleAmt / 2;
        vertex(x + wobble, y + wobble * 0.5);
      }

      // Right to bottom
      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const x = cx + (w / 2) * (1 - t);
        const y = cy + (h / 2) * t;
        const wobble = noise(seed + 20 + i * 0.3) * wobbleAmt - wobbleAmt / 2;
        vertex(x + wobble, y + wobble * 0.5);
      }

      // Bottom to left
      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const x = cx - t * (w / 2);
        const y = cy + (h / 2) * (1 - t);
        const wobble = noise(seed + 40 + i * 0.3) * wobbleAmt - wobbleAmt / 2;
        vertex(x + wobble, y + wobble * 0.5);
      }

      // Left to top
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const x = cx - (w / 2) * (1 - t);
        const y = cy - (h / 2) * t;
        const wobble = noise(seed + 60 + i * 0.3) * wobbleAmt - wobbleAmt / 2;
        vertex(x + wobble, y + wobble * 0.5);
      }

      endShape(CLOSE);
    }

    function drawBlurredWobblyMedallion(cx, cy, w, h, baseColor, alpha, blurAmount, wobbleAmt, seed) {
      const blurPasses = 4;
      for (let b = blurPasses; b >= 0; b--) {
        const expand = b * blurAmount * 0.5;
        const blurAlpha = alpha * (0.12 - b * 0.025);
        drawWobblyMedallion(cx, cy, w + expand, h + expand * 1.5, baseColor, blurAlpha, wobbleAmt, seed);
      }

      drawWobblyMedallion(cx, cy, w, h, baseColor, alpha, wobbleAmt, seed);
    }

    function drawWobblyMedallion(cx, cy, w, h, baseColor, alpha, wobbleAmt, seed) {
      const stripeW = 4;
      const numStripes = ceil(w / stripeW) + 2;

      for (let i = -numStripes/2; i <= numStripes/2; i++) {
        const stripeX = i * stripeW;
        if (abs(stripeX) > w/2 + stripeW) continue;

        const stripeBrightness = (i % 2 === 0) ? 0 : 15;
        const abrash = sin(i * 1.7 + w * 0.1) * 12;

        fill(
          constrain(baseColor[0] + stripeBrightness + abrash, 0, 255),
          constrain(baseColor[1] + stripeBrightness + abrash, 0, 255),
          constrain(baseColor[2] + stripeBrightness + abrash, 0, 255),
          alpha
        );

        const t = abs(stripeX) / (w/2 + 1);
        const stripeH = h * Math.pow(1 - t, 0.6);

        if (stripeH > 2) {
          // Wobble each vertex
          const wobbleTop = noise(seed + i * 0.5) * wobbleAmt - wobbleAmt / 2;
          const wobbleRight = noise(seed + i * 0.5 + 10) * wobbleAmt - wobbleAmt / 2;
          const wobbleBottom = noise(seed + i * 0.5 + 20) * wobbleAmt - wobbleAmt / 2;
          const wobbleLeft = noise(seed + i * 0.5 + 30) * wobbleAmt - wobbleAmt / 2;

          beginShape();
          vertex(cx + stripeX + wobbleTop, cy - stripeH/2 + wobbleTop * 0.3);
          vertex(cx + stripeX + stripeW/2 + wobbleRight, cy + wobbleRight * 0.3);
          vertex(cx + stripeX + wobbleBottom, cy + stripeH/2 + wobbleBottom * 0.3);
          vertex(cx + stripeX - stripeW/2 + wobbleLeft, cy + wobbleLeft * 0.3);
          endShape(CLOSE);
        }
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
