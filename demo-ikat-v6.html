<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Ikat Pattern v6 - Real Ikat Style</title>
  <style>
    body { margin: 0; background: #f5f0e6; overflow: hidden; }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #1a237e;
      font-family: system-ui;
      font-size: 14px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Ikat v6: Real Ikat Style</h2>
    <p>Symmetrical medallions with stepped edges</p>
    <p>Move mouse to draw</p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script>
    // Colors from the real Ikat reference
    const IKAT_COLORS = [
      [0, 131, 143],    // turquoise/teal
      [183, 28, 28],    // crimson
      [255, 193, 7],    // gold/yellow
      [106, 27, 154],   // purple
      [26, 35, 126],    // indigo
      [233, 30, 99],    // magenta/pink
    ];

    const BG_COLOR = [245, 240, 230]; // cream background

    let medallions = [];
    let prevMouse = { x: 0, y: 0 };

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(RGB);
      noStroke();
    }

    function draw() {
      // Cream background with slight fade
      background(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], 15);

      if (mouseX > 0 && mouseY > 0) {
        const dist = Math.sqrt(
          Math.pow(mouseX - prevMouse.x, 2) +
          Math.pow(mouseY - prevMouse.y, 2)
        );

        if (dist > 20) {
          spawnMedallion(mouseX, mouseY);
          prevMouse = { x: mouseX, y: mouseY };
        }
      }

      updateMedallions();
      drawMedallions();
    }

    function spawnMedallion(x, y) {
      const color1 = IKAT_COLORS[floor(random(IKAT_COLORS.length))];
      let color2 = IKAT_COLORS[floor(random(IKAT_COLORS.length))];
      while (color2 === color1) {
        color2 = IKAT_COLORS[floor(random(IKAT_COLORS.length))];
      }

      medallions.push({
        x: x,
        y: y,
        color1: color1,
        color2: color2,
        width: random(25, 45),
        height: random(50, 90),
        life: 1,
        decay: random(0.004, 0.009),
        steps: floor(random(6, 12))  // Number of horizontal steps for jagged edge
      });

      if (medallions.length > 80) medallions.shift();
    }

    function updateMedallions() {
      for (let i = medallions.length - 1; i >= 0; i--) {
        const m = medallions[i];
        m.life -= m.decay;

        if (m.life <= 0) {
          medallions.splice(i, 1);
        }
      }
    }

    function drawMedallions() {
      for (const m of medallions) {
        drawIkatMedallion(m);
      }
    }

    function drawIkatMedallion(m) {
      const alpha = m.life * 255;

      push();
      translate(m.x, m.y);

      // Outer medallion shape with stepped edges
      fill(m.color1[0], m.color1[1], m.color1[2], alpha);
      drawSteppedMedallion(0, 0, m.width, m.height, m.steps);

      // Inner contrasting medallion
      fill(m.color2[0], m.color2[1], m.color2[2], alpha);
      drawSteppedMedallion(0, 0, m.width * 0.55, m.height * 0.6, m.steps - 2);

      // Center detail - small diamond or dot
      fill(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], alpha);
      drawSteppedMedallion(0, 0, m.width * 0.2, m.height * 0.25, 3);

      pop();
    }

    function drawSteppedMedallion(cx, cy, w, h, steps) {
      // Create the characteristic Ikat stepped/jagged edge medallion
      // Shape: pointed at top and bottom, wide in middle (like a flame or feather)

      steps = max(3, steps);
      const halfH = h / 2;
      const stepH = h / (steps * 2);

      beginShape();

      // Right side - top to middle (expanding)
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const y = cy - halfH + t * halfH;
        // Curve that expands: starts narrow, gets wide
        const widthAtStep = w/2 * Math.pow(t, 0.7);
        // Add small random jitter for that hand-dyed look
        const jitter = (Math.sin(i * 3.7) * 0.5 + 0.5) * 2;
        vertex(cx + widthAtStep + jitter, y);
      }

      // Right side - middle to bottom (contracting)
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const y = cy + t * halfH;
        const widthAtStep = w/2 * Math.pow(1 - t, 0.7);
        const jitter = (Math.sin(i * 4.3) * 0.5 + 0.5) * 2;
        vertex(cx + widthAtStep + jitter, y);
      }

      // Left side - bottom to middle (expanding) - mirror
      for (let i = steps; i >= 0; i--) {
        const t = i / steps;
        const y = cy + t * halfH;
        const widthAtStep = w/2 * Math.pow(1 - t, 0.7);
        const jitter = (Math.sin(i * 4.3 + 1) * 0.5 + 0.5) * 2;
        vertex(cx - widthAtStep - jitter, y);
      }

      // Left side - middle to top (contracting) - mirror
      for (let i = steps; i >= 0; i--) {
        const t = i / steps;
        const y = cy - halfH + t * halfH;
        const widthAtStep = w/2 * Math.pow(t, 0.7);
        const jitter = (Math.sin(i * 3.7 + 1) * 0.5 + 0.5) * 2;
        vertex(cx - widthAtStep - jitter, y);
      }

      endShape(CLOSE);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
