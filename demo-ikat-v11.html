<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Ikat Pattern v11 - Varied Centers</title>
  <style>
    body { margin: 0; background: #f5f0e6; overflow: hidden; }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #1a237e;
      font-family: system-ui;
      font-size: 14px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Ikat v11: Varied Centers</h2>
    <p>Rhombs with different center shapes</p>
    <p>Move mouse to draw</p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script>
    const IKAT_COLORS = [
      [0, 131, 143],    // turquoise
      [183, 28, 28],    // crimson
      [255, 193, 7],    // gold
      [106, 27, 154],   // purple
      [26, 35, 126],    // indigo
      [233, 30, 99],    // magenta
      [46, 125, 50],    // green
      [27, 94, 32],     // dark green
      [0, 150, 136],    // teal green
      [33, 150, 243],   // blue
      [13, 71, 161],    // dark blue
      [3, 169, 244],    // light blue
      [20, 20, 20],     // black
      [250, 250, 250],  // white
    ];

    const BG_COLOR = [245, 240, 230];
    const CENTER_SHAPES = ['rhombus', 'heart', 'curl', 'star', 'flower'];

    let medallions = [];
    let prevMouse = { x: 0, y: 0 };

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(RGB);
      noStroke();
    }

    function draw() {
      background(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], 10);

      if (mouseX > 0 && mouseY > 0) {
        const dist = Math.sqrt(
          Math.pow(mouseX - prevMouse.x, 2) +
          Math.pow(mouseY - prevMouse.y, 2)
        );

        if (dist > 12) {
          spawnMedallion(mouseX, mouseY);
          prevMouse = { x: mouseX, y: mouseY };
        }
      }

      updateMedallions();
      drawMedallions();
    }

    function spawnMedallion(x, y) {
      const color1 = IKAT_COLORS[floor(random(IKAT_COLORS.length))];
      let color2 = IKAT_COLORS[floor(random(IKAT_COLORS.length))];
      while (color2 === color1) {
        color2 = IKAT_COLORS[floor(random(IKAT_COLORS.length))];
      }
      let color3 = IKAT_COLORS[floor(random(IKAT_COLORS.length))];

      medallions.push({
        x: x,
        y: y,
        color1: color1,
        color2: color2,
        color3: color3,
        width: random(80, 130),
        height: random(180, 300),
        life: 1,
        decay: random(0.002, 0.005),
        centerShape: CENTER_SHAPES[floor(random(CENTER_SHAPES.length))]
      });

      if (medallions.length > 60) medallions.shift();
    }

    function updateMedallions() {
      for (let i = medallions.length - 1; i >= 0; i--) {
        const m = medallions[i];
        m.life -= m.decay;

        if (m.life <= 0) {
          medallions.splice(i, 1);
        }
      }
    }

    function drawMedallions() {
      for (const m of medallions) {
        drawIkatMedallion(m);
      }
    }

    function drawIkatMedallion(m) {
      const alpha = m.life * 255;

      push();
      translate(m.x, m.y);

      // Outer medallion
      drawTexturedMedallion(0, 0, m.width, m.height, m.color1, alpha);

      // Middle layer
      drawTexturedMedallion(0, 0, m.width * 0.55, m.height * 0.6, m.color2, alpha);

      // Center shape (varied)
      drawCenterShape(m, alpha);

      pop();
    }

    function drawTexturedMedallion(cx, cy, w, h, baseColor, alpha) {
      const stripeW = 4;
      const numStripes = ceil(w / stripeW) + 2;

      for (let i = -numStripes/2; i <= numStripes/2; i++) {
        const stripeX = i * stripeW;
        if (abs(stripeX) > w/2 + stripeW) continue;

        const stripeBrightness = (i % 2 === 0) ? 0 : 20;
        const abrash = sin(i * 1.7) * 10;

        fill(
          constrain(baseColor[0] + stripeBrightness + abrash, 0, 255),
          constrain(baseColor[1] + stripeBrightness + abrash, 0, 255),
          constrain(baseColor[2] + stripeBrightness + abrash, 0, 255),
          alpha
        );

        const t = abs(stripeX) / (w/2 + 1);
        const stripeH = h * Math.pow(1 - t, 0.6);

        if (stripeH > 2) {
          beginShape();
          vertex(cx + stripeX, cy - stripeH/2);
          vertex(cx + stripeX + stripeW/2, cy);
          vertex(cx + stripeX, cy + stripeH/2);
          vertex(cx + stripeX - stripeW/2, cy);
          endShape(CLOSE);
        }
      }
    }

    function drawCenterShape(m, alpha) {
      const w = m.width * 0.25;
      const h = m.height * 0.2;

      switch(m.centerShape) {
        case 'rhombus':
          drawCenterRhombus(w, h, m.color3, alpha);
          break;
        case 'heart':
          drawCenterHeart(w, h, m.color3, alpha);
          break;
        case 'curl':
          drawCenterCurl(w, h, m.color3, alpha);
          break;
        case 'star':
          drawCenterStar(w, h, m.color3, alpha);
          break;
        case 'flower':
          drawCenterFlower(w, h, m.color3, alpha);
          break;
      }
    }

    // Center: Rhombus
    function drawCenterRhombus(w, h, color, alpha) {
      fill(color[0], color[1], color[2], alpha);
      beginShape();
      vertex(0, -h/2);
      vertex(w/2, 0);
      vertex(0, h/2);
      vertex(-w/2, 0);
      endShape(CLOSE);

      // Inner detail
      fill(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], alpha);
      beginShape();
      vertex(0, -h/4);
      vertex(w/4, 0);
      vertex(0, h/4);
      vertex(-w/4, 0);
      endShape(CLOSE);
    }

    // Center: Heart
    function drawCenterHeart(w, h, color, alpha) {
      fill(color[0], color[1], color[2], alpha);
      beginShape();
      vertex(0, h/3);  // bottom point
      // Left curve
      bezierVertex(-w/2, 0, -w/2, -h/3, 0, -h/6);
      // Right curve
      bezierVertex(w/2, -h/3, w/2, 0, 0, h/3);
      endShape(CLOSE);

      // Highlight
      fill(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], alpha * 0.5);
      ellipse(-w/6, -h/8, w/5, h/6);
    }

    // Center: Curls (mirrored S-curves)
    function drawCenterCurl(w, h, color, alpha) {
      stroke(color[0], color[1], color[2], alpha);
      strokeWeight(w/6);
      noFill();

      // Left curl
      beginShape();
      curveVertex(-w/3, -h/3);
      curveVertex(-w/4, -h/4);
      curveVertex(-w/6, 0);
      curveVertex(-w/4, h/4);
      curveVertex(-w/3, h/3);
      endShape();

      // Right curl (mirrored)
      beginShape();
      curveVertex(w/3, -h/3);
      curveVertex(w/4, -h/4);
      curveVertex(w/6, 0);
      curveVertex(w/4, h/4);
      curveVertex(w/3, h/3);
      endShape();

      noStroke();

      // Center dot
      fill(color[0], color[1], color[2], alpha);
      ellipse(0, 0, w/5, w/5);
    }

    // Center: Star
    function drawCenterStar(w, h, color, alpha) {
      fill(color[0], color[1], color[2], alpha);
      const points = 6;
      const outerR = min(w, h) / 2;
      const innerR = outerR * 0.4;

      beginShape();
      for (let i = 0; i < points * 2; i++) {
        const angle = i * PI / points - PI/2;
        const r = i % 2 === 0 ? outerR : innerR;
        vertex(cos(angle) * r * 0.8, sin(angle) * r);
      }
      endShape(CLOSE);

      // Center
      fill(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], alpha);
      ellipse(0, 0, innerR * 0.8, innerR * 0.8);
    }

    // Center: Flower (4 petals)
    function drawCenterFlower(w, h, color, alpha) {
      fill(color[0], color[1], color[2], alpha);

      // 4 petals
      for (let i = 0; i < 4; i++) {
        push();
        rotate(i * PI/2);
        ellipse(0, -h/4, w/3, h/3);
        pop();
      }

      // Center circle
      fill(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], alpha);
      ellipse(0, 0, w/4, w/4);

      // Inner dot
      fill(color[0], color[1], color[2], alpha);
      ellipse(0, 0, w/8, w/8);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
